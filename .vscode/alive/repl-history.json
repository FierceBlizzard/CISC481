[{"pkgName":"cl-user","text":"(aref puzzle0 (+ row 1) col)"},{"pkgName":"cl-user","text":"(aref puzzle0 row col)"},{"pkgName":"cl-user","text":"(setf row 0)"},{"pkgName":"cl-user","text":"(setf col 0)"},{"pkgName":"cl-user","text":"(setf temp (aref puzzle0 0 0))"},{"pkgName":"cl-user","text":"temp"},{"pkgName":"cl-user","text":"(setf temp 0)"},{"pkgName":"cl-user","text":"(aref puzzle0 0 0)"},{"pkgName":"cl-user","text":"(aref puzzle 0 0)"},{"pkgName":"cl-user","text":"(defvar puzzle0 #2A ((3 1 2)                        (7 nil 5)                        (4 6 8)))"},{"pkgName":"cl-user","text":"(let 0 temp)"},{"pkgName":"cl-user","text":"(let temp 0)"},{"pkgName":"cl-user","text":"(defun possible-actions (puzzle)     (dotimes (row 3)         (dotimes (col 3)             (when                  (null (aref puzzle))             (setq rowN row)             (setq colN col)             )         )     )     (cond          ;;movement for going left and right         ((>= rowN 0) (append possAct :right))         ((>= rowN 1) (append possAct :left))         ((= rowN 2)  (remove :right possAct))         ((= rowN 0)  (remove :left possAct))          ;;movement for going up and down         ((>= colN 0) (append possAct :down))         ((>= colN 1) (append possAct :up))         ((= colN 2)  (remove :down possAct))         ((= colN 0)  (remove :up possAct))     )     (possAct) )"},{"pkgName":"cl-user","text":"(let ((rowN 0)         (colN 0)         (temp 0)         possAct)     (setq possAct '())   )"},{"pkgName":"cl-user","text":"(defvar *puzzle-0*'((3 1 2)                        (7 nil 5)                        (4 6 8)))"},{"pkgName":"cl-user","text":"(defvar *puzzle-0*'((3 1 2)                        (7 nil 5)                        (4 6 8)))  (let ((rowN 0)         (colN 0)         (temp 0)         possAct)     (setq possAct '())   ) (defun possible-actions (puzzle)     (dotimes (row 3)         (dotimes (col 3)             (when                  (null (aref puzzle))             (setq rowN row)             (setq colN col)             )         )     )     (cond          ;;movement for going left and right         ((>= rowN 0) (append possAct :right))         ((>= rowN 1) (append possAct :left))         ((= rowN 2)  (remove :right possAct))         ((= rowN 0)  (remove :left possAct))          ;;movement for going up and down         ((>= colN 0) (append possAct :down))         ((>= colN 1) (append possAct :up))         ((= colN 2)  (remove :down possAct))         ((= colN 0)  (remove :up possAct))     )     (possAct) )  (defun result (puzzle action)     (cond          ;;movement for going left and right         ((eq action :right) ((setq temp (aref puzzle (colN (+ rowN 1))))                             (setq (aref puzzle colN rowN) temp)                             (setq (aref puzzle colN (+ rowN 1)) nil)                             )         )         ((eq action :left) ((setq temp (aref puzzle (colN (- rowN 1))))                             (setq (aref puzzle colN rowN) temp)                             (setq (aref puzzle colN (- rowN 1)) nil)                             )         )          ;;movement for going up and down         ((eq action :down) ((setq temp (aref puzzle ((+ colN 1) rowN)))                             (setq (aref puzzle colN rowN) temp)                             (setq (aref puzzle (+ colN 1) rowN) nil)                             )         )         ((eq action :up) ((setq temp (aref puzzle ((- colN 1) rowN)))                             (setq (aref puzzle colN rowN) temp)                             (setq (aref puzzle (- colN 1) rowN) nil)                             )         )     )     (puzzle) ) (result *puzzle-0*) (write *puzzle-0*)"}]
(defvar *puzzle-0* #2A ((3 1 2)
                       (7 nil 5)
                       (4 6 8)))
(defvar *goal* #2A  ((nil 1 2)
                     (3 4 5)
                     (6 7 8)))
(defvar colN 0)
(defvar rowN 0)
(list :state puzzle
      :parent curr
      action
      :path-cost 0
)

(defun possible-actions (puzzle)
    (setf possAct '())
    (dotimes (row 2)
        (dotimes (col 2)
            (when 
                (null (aref puzzle))
            (setf rowN row)
            (setf colN col)
            )
        )
    )
    (cond 
        ;;movement for going left and right
        ((>= rowN 0) (append possAct :right))
        ((>= rowN 1) (append possAct :left))
        ((= rowN 2)  (remove :right possAct))
        ((= rowN 0)  (remove :left possAct))

        ;;movement for going up and down
        ((>= colN 0) (append possAct :down))
        ((>= colN 1) (append possAct :up))
        ((= colN 2)  (remove :down possAct))
        ((= colN 0)  (remove :up possAct))
    )
    (possAct)
)

(defun result (puzzle action)
    (setf temp 0)
    (cond 
        ;;movement for going left and right
        ((eq action :right) 
            (setf temp (aref puzzle colN (+ rowN 1)))
            (setf (aref puzzle colN rowN) temp)
            (setf (aref puzzle colN (+ rowN 1)) nil)                   
        )
        ((eq action :left) 
            (setf temp (aref puzzle colN (- rowN 1)))
            (setf (aref puzzle colN rowN) temp)
            (setf (aref puzzle colN (- rowN 1)) nil)                  
        )
        ;;movement for going up and down
        ((eq action :down) 
            (setf temp (aref puzzle (+ colN 1) rowN))
            (setf (aref puzzle colN rowN) temp)
            (setf (aref puzzle (+ colN 1) rowN) nil)
        )
        ((eq action :up)
            (setf temp (aref puzzle (- colN 1) rowN))
            (setf (aref puzzle colN rowN) temp)
            (setf (aref puzzle (- colN 1) rowN) nil)
        )
    )
    (puzzle)
)
(defun expand (puzzle action)
    (result puzzle action)
)
;;
(defun iterative-search (puzzle)
    (setf end 2)
    (setf start 1)
    (setf numIter 1)
    (setf winner_path '())
    (setf currPuzzle puzzle)
)
(write *puzzle-0*)
(pprint iterative-search)